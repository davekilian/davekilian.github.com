<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" href="css/bootstrap.css" />
        <style type="text/css">
            ul.nav
            {
                list-style-type: none;
                position:relative;
                margin:0;
                padding:0;
                margin-top:30px
            }
            
            ul.nav li
            {
                border:none;
                padding:0;
                margin:0;
                margin-bottom:10px
            }
        </style>
    </head>
    <body>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span2" style="background-color:#eee; padding: 1em; position: fixed; right: 0px; height: 100%">
                    <img style="margin-bottom: 1em" src="http://1.gravatar.com/avatar/45adbee0467afae3e26db7d060e0b386"</img>
                    <h1>Dave<br>Kilian</h1>
                    <ul class="nav">
                        <li><h4><a href="">Blog</a></h4></li>
                        <li><h4><a href="">About</a></h4></li>
                        <li><h4><a href="http://www.github.com/davekilian">GitHub</a></h4></li>
                        <li><h4><a href="">Contact</a></h4></li>
                    </ul>
                    <footer style="position: fixed; bottom: 1em;">
                        <h5>&copy; Dave Kilian 2012</h5>
                    </footer>
                </div>
                <div class="span10" style="padding: 1em">
                    <header style="padding-bottom: 1em">
                        <h1>Game Networking I</h1>
                        <h6>14 July 2012</h6>
                    </header>
                <p>Welcome to game networking! In this series of posts, we&#8217;ll build a simple multiplayer first-person shooter that we can play over the Internet. Along the way we&#8217;ll talk about all the lies networked games tell their players. Our system will be playable over (reasonably) slow or unreliable connections, and we&#8217;ll take some basic steps to mitigate cheating.</p>

<p>The system we&#8217;ll build is based on the networked multiplayer system we built for <a href='http://fracture-studios.com/404'>nullZERO</a>. It draws heavily from documents published by the people who made <a href='TODO'>Valve&#8217;s Source Engine</a> and <a href='TODO'>id Software&#8217;s QuakeWorld</a>.</p>

<p>Pages we found particularly useful include:</p>

<ul>
<li>TODO</li>

<li>Links from the nullzero client-server doc</li>
</ul>

<h2 id='prerequisites'>Prerequisites</h2>

<p>This series is aimed at readers who have some experience creating 3D video games. Specifically, you should be able to write the skeleton for a single-player first-person shooter without much difficulty.</p>

<p>Additionally, each post in this series is accompanied by example code, written in C++ using the <a href='http://qt.nokia.com/'>Qt Framework</a>. Although not strictly necessary, being able to read the example code will be helpful if you get stuck.</p>

<p>Ready to start? Before moving on to the next part of this tutorial, please take some time to read Glenn Fielder&#8217;s excellent series <a href='http://gafferongames.com/networking-for-game-programmers/'>Networking for Game Programmers</a>. The rest of this tutorial will assume you&#8217;ve already done so.</p>

<h2 id='review_smart_servers_and_dumb_clients'>Review: Smart Servers and Dumb Clients</h2>

<p>In a client/server architecture, several players each interface with a client connected to the central server. The server runs all simulation logic and broadcasts the results to the clients. The clients simply render the results and collect the players&#8217; inputs. The server uses these player inputs to modify the simulation.</p>

<p>Ideally, this would mean the client doesn&#8217;t need to know any of the simulation logic. Unfortunately, this is not the case: to work smoothly over an imperfect connection, the client will need to run simulation logic on player input before the input reaches the server.</p>

<p>In future posts, we&#8217;ll talk about expanding the client this way, but for now we&#8217;ll assume the client is a dumb terminal that just renders the server&#8217;s simulation.</p>

<h2 id='what_is_a_simulation'>What is a Simulation?</h2>

<p>We&#8217;ll use the term <em>simulation</em> to mean a sequence of <em>events</em> that happen over time. &#8220;Time&#8221; in terms of the simulation is not the same as real-world clock time. For example, we could choose to run a simulation at half speed, which means 1s of simulation time elapses every 2s of real-world time.</p>

<p>To avoid ambiguity, we will always refer to virtual simulation time as <em>simulation time</em> or <em>sim-time</em>, and real-world physical time as <em>wall time</em>.</p>

<p>With this, we can more precisely state the jobs of the server and client:</p>

<ul>
<li>
<p>The server generates simulation events, as dictated by the simulation logic and client inputs. The simulation time always matches the server&#8217;s wall time perfectly.</p>
</li>

<li>
<p>The client renders the simulation. The simulation time being rendered is always a small, constant amount earlier than the client&#8217;s wall time.</p>
</li>
</ul>

<p>Note that wall time may be different for the client and server, but the simulation time will always match (since the client and server are dealing with the same simulation).</p>

<h2 id='example_code'>Example Code</h2>

<p>TODO</p>

<p>Now that we&#8217;ve got some of the basics out of the way, we can start building our system. Head on over to <a href='TODO'>Networking II: Client/Server Architectures</a> when you&#8217;re ready!</p>

<hr/>
<a href="index.html">Back to Blog index</a>
                </div>
            </div>
        </div>
    </body>
</html>
